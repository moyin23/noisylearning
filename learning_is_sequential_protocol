function learning_is_sequential_protocol(C,d,k)
% Code that imposes SPD constrains on a variable C to enforce that C is a valid
% sequential superchannel
% 'd' corresponds to the dimension of the systems in which the
% output-operation is applied
% 'k' corresponds to the number of uses of the input-operation

    cvx_begin SDP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% case of 2 copies
if k==2
     % Declare the SDP variables corresponding to the encoders with memory
     PartialTrace(C,6,[d d d d d d]) == kron(PartialTrace(C,[4 5 6],[d d d d d d]),eye(d^2)/(d^2));
     PartialTrace(C,[3 4 5 6],[d d d d d d]) == kron(PartialTrace(C,[2 3 4 5 6],[d d d d d d]),eye(d)/d);
     trace(C) == 8;
end %end if k==2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% case of 3 copies
if k==3  
    PartialTrace(C,8, [d d d d d d d d]) == kron(PartialTrace(C,[6 7 8], [d d d d d d d d]),eye(d^2)/(d^2));
    PartialTrace(C,[5 6 7 8], [d d d d d d d d]) == kron(PartialTrace(C,[4 5 6 7 8], [d d d d d d d d]),eye(d)/d);
    PartialTrace(C,[3 4 5 6 7 8], [d d d d d d d d]) == kron(PartialTrace(C,[2 3 4 5 6 7 8], [d d d d d d d d]),eye(d)/d);
    trace(C) == 16;     
end %end if k==3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% case of 4 copies
if k==4  
    PartialTrace(C,10, [d d d d d d d d d d]) == kron(PartialTrace(C,[8 9 10], [d d d d d d d d d d]),eye(d^2)/(d^2));
    PartialTrace(C,[7 8 9 10], [d d d d d d d d d d]) == kron(PartialTrace(C,[6 7 8 9 10], [d d d d d d d d d d]),eye(d)/d);
    PartialTrace(C,[5 6 7 8 9 10], [d d d d d d d d d d]) == kron(PartialTrace(C,[4 5 6 7 8 9 10], [d d d d d d d d d d]),eye(d)/d);
    PartialTrace(C,[3 4 5 6 7 8 9 10], [d d d d d d d d d d]) == kron(PartialTrace(C,[2 3 4 5 6 7 8 9 10], [d d d d d d d d d d]),eye(d)/d);
    trace(C) == 32;     
end %end if k==4
    cvx_end
end
