function [maxf D] = learning_maxf_dual_parallel(k,g,d,isComplex)
% Code that evaluates the maximal fidelity of learning the set of
% k unitaries (g of k are good)
% 'k' corresponds to the number of uses of the input-operation
% 'g' corresponds to the number of good unitaries
% 'd' corresponds to SU(d)
% if isComplex is '0', the code only consider supermaps with real numbers
% is isComples is '1', the code considers general supermaps with complex
% numbers

Omega = learning_omega(k,g,d);
'Parallel PROTOCOL'
    cvx_begin SDP
    cvx_solver mosek
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% case of 2 copies
if k==2
    variable f
   % Declare the SDP variables related to C
    if isComplex==1
        variable D(d^6,d^6) complex semidefinite
    else
        variable D(d^6,d^6) semidefinite
    end
    minimize f
    D >= Omega;
    learning_is_parallel_protocol_dual(D,d,k,f);
end %end if k==2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% case of 3 copies
if k==3
    variable f
   % Declare the SDP variables related to C
    if isComplex==1
        variable D(d^8,d^8) complex semidefinite
    else
        variable D(d^8,d^8) semidefinite
    end
    minimize f
    D >= Omega;
    learning_is_parallel_protocol_dual(D,d,k,f);
end %end if k==3
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% case of 4 copies
if k==4
    variable f
   % Declare the SDP variables related to C
    if isComplex==1
        variable D(d^8,d^8) complex semidefinite
    else
        variable D(d^8,d^8) semidefinite
    end
    minimize f
    D >= Omega;
    learning_is_parallel_protocol_dual(D,d,k,f);
end %end if k==4
%%%%%%%%%%%%%%%%%%%%%%%%
%finish SDP
    cvx_end
    maxf=f;
    D=D;
end
